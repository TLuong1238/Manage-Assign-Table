import { supabase } from '../lib/supabase';

// ===================
// BILL DATA QUERIES
// ===================

/**
 * L·∫•y t·∫•t c·∫£ bills trong kho·∫£ng th·ªùi gian
 * @param {Date} startDate - Ng√†y b·∫Øt ƒë·∫ßu
 * @param {Date} endDate - Ng√†y k·∫øt th√∫c
 * @returns {Promise<{success: boolean, data?: Array, msg?: string}>}
 */
export const getBillsInDateRange = async (startDate, endDate) => {
    try {
        console.log(`üìä Fetching bills from ${startDate} to ${endDate}`);
        
        const { data, error } = await supabase
            .from('bills')
            .select('*')
            .gte('created_at', startDate)
            .lte('created_at', endDate)
            .order('created_at', { ascending: false });

        if (error) {
            console.error('‚ùå Error fetching bills:', error);
            return { 
                success: false, 
                msg: `L·ªói t·∫£i d·ªØ li·ªáu: ${error.message}` 
            };
        }

        console.log(`‚úÖ Successfully fetched ${data?.length || 0} bills`);
        return { 
            success: true, 
            data: data || [] 
        };

    } catch (error) {
        console.error('‚ùå Unexpected error in getBillsInDateRange:', error);
        return { 
            success: false, 
            msg: 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫£i d·ªØ li·ªáu' 
        };
    }
};

/**
 * L·∫•y bills theo ng√†y c·ª• th·ªÉ
 * @param {Date} date - Ng√†y c·∫ßn l·∫•y
 * @returns {Promise<{success: boolean, data?: Array, msg?: string}>}
 */
export const getBillsByDate = async (date) => {
    const startDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
    const endDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59);
    
    return await getBillsInDateRange(startDate.toISOString(), endDate.toISOString());
};

/**
 * L·∫•y bills theo tu·∫ßn
 * @param {Date} date - Ng√†y trong tu·∫ßn c·∫ßn l·∫•y
 * @returns {Promise<{success: boolean, data?: Array, msg?: string}>}
 */
export const getBillsByWeek = async (date) => {
    const weekStart = new Date(date);
    weekStart.setDate(date.getDate() - date.getDay());
    weekStart.setHours(0, 0, 0, 0);
    
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);
    
    return await getBillsInDateRange(weekStart.toISOString(), weekEnd.toISOString());
};

/**
 * L·∫•y bills theo th√°ng
 * @param {Date} date - Ng√†y trong th√°ng c·∫ßn l·∫•y
 * @returns {Promise<{success: boolean, data?: Array, msg?: string}>}
 */
export const getBillsByMonth = async (date) => {
    const startDate = new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0);
    const endDate = new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59);
    
    return await getBillsInDateRange(startDate.toISOString(), endDate.toISOString());
};

/**
 * L·∫•y bills theo lo·∫°i b√°o c√°o
 * @param {string} reportType - 'daily', 'weekly', 'monthly'
 * @param {Date} selectedDate - Ng√†y ƒë∆∞·ª£c ch·ªçn
 * @returns {Promise<{success: boolean, data?: Array, msg?: string}>}
 */
export const getBillsByReportType = async (reportType, selectedDate) => {
    console.log(`üìä Fetching bills for ${reportType} report on ${selectedDate.toDateString()}`);
    
    switch (reportType) {
        case 'daily':
            return await getBillsByDate(selectedDate);
        case 'weekly':
            return await getBillsByWeek(selectedDate);
        case 'monthly':
            return await getBillsByMonth(selectedDate);
        default:
            return await getBillsByDate(selectedDate);
    }
};

// ===================
// STATISTICS CALCULATION
// ===================

/**
 * T√≠nh to√°n th·ªëng k√™ c∆° b·∫£n t·ª´ danh s√°ch bills
 * @param {Array} bills - Danh s√°ch bills
 * @returns {Object} Th·ªëng k√™ c∆° b·∫£n
 */
export const calculateBasicStats = (bills) => {
    const totalBills = bills.length;
    const completedBills = bills.filter(bill => bill.state === 'completed');
    const cancelledBills = bills.filter(bill => bill.state === 'cancelled');
    const inOrderBills = bills.filter(bill => bill.state === 'in_order');
    
    return {
        totalBills,
        completedBills: completedBills.length,
        cancelledBills: cancelledBills.length,
        inOrderBills: inOrderBills.length,
        completedBillsData: completedBills,
        cancelledBillsData: cancelledBills,
        inOrderBillsData: inOrderBills
    };
};

/**
 * T√≠nh to√°n th·ªëng k√™ doanh thu
 * @param {Array} completedBills - Danh s√°ch bills ƒë√£ ho√†n th√†nh
 * @returns {Object} Th·ªëng k√™ doanh thu
 */
export const calculateRevenueStats = (completedBills) => {
    const totalRevenue = completedBills.reduce((sum, bill) => sum + (bill.price || 0), 0);
    const avgOrderValue = completedBills.length > 0 ? totalRevenue / completedBills.length : 0;
    
    const totalCustomers = completedBills.reduce((sum, bill) => sum + (bill.num_people || 0), 0);
    const avgPartySize = completedBills.length > 0 ? totalCustomers / completedBills.length : 0;
    
    return {
        totalRevenue,
        avgOrderValue,
        totalCustomers,
        avgPartySize
    };
};

/**
 * T√≠nh to√°n th·ªëng k√™ visit
 * @param {Array} bills - Danh s√°ch t·∫•t c·∫£ bills
 * @returns {Object} Th·ªëng k√™ visit
 */
export const calculateVisitStats = (bills) => {
    const checkedInBills = bills.filter(bill => 
        bill.visit === 'in_process' || bill.visit === 'visited'
    );
    const noShowBills = bills.filter(bill => 
        bill.state === 'cancelled' && bill.visit === 'un_visited'
    );
    
    const totalBills = bills.length;
    const checkInRate = totalBills > 0 ? (checkedInBills.length / totalBills * 100) : 0;
    const noShowRate = totalBills > 0 ? (noShowBills.length / totalBills * 100) : 0;
    
    return {
        checkedInBills: checkedInBills.length,
        noShowBills: noShowBills.length,
        checkInRate,
        noShowRate
    };
};

/**
 * Ph√¢n t√≠ch patterns theo th·ªùi gian
 * @param {Array} bills - Danh s√°ch bills
 * @returns {Object} Th·ªëng k√™ th·ªùi gian
 */
export const analyzeTimePatterns = (bills) => {
    if (bills.length === 0) {
        return {
            timeSlots: {
                morning: 0,
                lunch: 0,
                afternoon: 0,
                dinner: 0,
                night: 0
            },
            peakTime: { time: '', count: 0 }
        };
    }
    
    const timeSlots = {
        morning: 0,    // 6-11
        lunch: 0,      // 11-14
        afternoon: 0,  // 14-17
        dinner: 0,     // 17-22
        night: 0       // 22-6
    };
    
    bills.forEach(bill => {
        const hour = new Date(bill.time || bill.created_at).getHours();
        
        if (hour >= 6 && hour < 11) timeSlots.morning++;
        else if (hour >= 11 && hour < 14) timeSlots.lunch++;
        else if (hour >= 14 && hour < 17) timeSlots.afternoon++;
        else if (hour >= 17 && hour < 22) timeSlots.dinner++;
        else timeSlots.night++;
    });
    
    // T√¨m peak time
    const peakTime = Object.entries(timeSlots).reduce((peak, [time, count]) => 
        count > peak.count ? { time, count } : peak, { time: '', count: 0 }
    );
    
    return { timeSlots, peakTime };
};

/**
 * Ph√¢n t√≠ch ph√¢n b·ªë theo gi·ªù
 * @param {Array} bills - Danh s√°ch bills
 * @returns {Array} M·∫£ng 24 ph·∫ßn t·ª≠ th·ªÉ hi·ªán s·ªë bills theo gi·ªù
 */
export const analyzeHourlyDistribution = (bills) => {
    const hours = Array(24).fill(0);
    
    bills.forEach(bill => {
        const hour = new Date(bill.time || bill.created_at).getHours();
        if (hour >= 0 && hour < 24) {
            hours[hour]++;
        }
    });
    
    return hours;
};

/**
 * T√≠nh to√°n to√†n b·ªô th·ªëng k√™
 * @param {Array} bills - Danh s√°ch bills
 * @returns {Object} T·∫•t c·∫£ th·ªëng k√™
 */
export const calculateAllStats = (bills) => {
    console.log(`üìä Calculating stats for ${bills.length} bills`);
    
    // Basic stats
    const basicStats = calculateBasicStats(bills);
    
    // Revenue stats (ch·ªâ t·ª´ completed bills)
    const revenueStats = calculateRevenueStats(basicStats.completedBillsData);
    
    // Visit stats
    const visitStats = calculateVisitStats(bills);
    
    // Time analysis
    const timeStats = analyzeTimePatterns(bills);
    const hourlyStats = analyzeHourlyDistribution(bills);
    
    const allStats = {
        ...basicStats,
        ...revenueStats,
        ...visitStats,
        ...timeStats,
        hourlyStats
    };
    
    console.log('‚úÖ Stats calculation completed:', {
        totalBills: allStats.totalBills,
        totalRevenue: allStats.totalRevenue,
        checkInRate: allStats.checkInRate.toFixed(1) + '%',
        peakTime: allStats.peakTime
    });
    
    return allStats;
};

// ===================
// REPORT HELPERS
// ===================

/**
 * Format date range cho display
 * @param {string} reportType - Lo·∫°i b√°o c√°o
 * @param {Date} selectedDate - Ng√†y ƒë∆∞·ª£c ch·ªçn
 * @returns {string} Date range formatted
 */
export const formatDateRange = (reportType, selectedDate) => {
    const date = new Date(selectedDate);
    
    switch (reportType) {
        case 'daily':
            return date.toLocaleDateString('vi-VN', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
        case 'weekly':
            const weekStart = new Date(date);
            weekStart.setDate(date.getDate() - date.getDay());
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);
            
            return `${weekStart.toLocaleDateString('vi-VN')} - ${weekEnd.toLocaleDateString('vi-VN')}`;
            
        case 'monthly':
            return date.toLocaleDateString('vi-VN', {
                year: 'numeric',
                month: 'long'
            });
            
        default:
            return date.toLocaleDateString('vi-VN');
    }
};

// ===================
// REAL-TIME SUBSCRIPTIONS
// ===================

/**
 * Setup realtime subscription cho bills
 * @param {Function} onBillChange - Callback khi c√≥ thay ƒë·ªïi
 * @returns {Function} Cleanup function
 */
export const subscribeToBills = (onBillChange) => {
    console.log('üì° Setting up bills realtime subscription');
    
    const channel = supabase
        .channel('bills-realtime')
        .on('postgres_changes', {
            event: '*',
            schema: 'public',
            table: 'bills'
        }, (payload) => {
            console.log('üí´ Bills change detected:', payload.eventType, payload.new?.id || payload.old?.id);
            onBillChange(payload);
        })
        .subscribe();

    // Return cleanup function
    return () => {
        console.log('üßπ Cleaning up bills subscription');
        supabase.removeChannel(channel);
    };
};